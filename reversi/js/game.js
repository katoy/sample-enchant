// Generated by CoffeeScript 1.6.2
/*
リバーシ。
盤面のクラスと、単純なコンピュータ試行ルーチン２つ。
*/


(function() {
  var AI_Base, AI_First, AI_Gain, AI_Montecarlo, AI_Negamax, AI_Random, Rating, Reversi, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Reversi = (function() {
    var dXY, setMessage, setStatMessage;

    Reversi.STONE_IMAGE_WIDTH = 50;

    Reversi.STONE_IMAGE_HEIGHT = 50;

    Reversi.VOID = 'images/void.jpg';

    Reversi.BLACK = 'images/black.jpg';

    Reversi.WHITE = 'images/white.jpg';

    Reversi.HINT_B = 'images/hintB.jpg';

    Reversi.HINT_W = 'images/hintW.jpg';

    dXY = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];

    function Reversi(core, gameSize, stoneDispWidth) {
      this.gameSize = gameSize != null ? gameSize : 8;
      this.stoneDispWidth = stoneDispWidth != null ? stoneDispWidth : 1.0;
      this.fps = core.fps;
      this.num_stone = this.gameSize * this.gameSize;
      this.scale = this.stoneDispWidth / Reversi.STONE_IMAGE_WIDTH;
      this.SPRITES = [];
      this.BoardState = [];
      this.turn = 1;
      this.start = false;
      this.BlackStone = this.WhiteStone = 0;
      this.players = [0, 0];
      this.records = [];
      this.play_pos = 0;
      this.replay_mode = false;
      core.preload([Reversi.VOID, Reversi.BLACK, Reversi.WHITE, Reversi.HINT_B, Reversi.HINT_W]);
    }

    Reversi.prototype.setCPUs = function(cpus) {
      this.cpus = cpus;
    };

    Reversi.prototype.isInBoard = function(x, y) {
      return (x >= 0) && (x < this.gameSize) && (y >= 0) && (y < this.gameSize);
    };

    Reversi.prototype.xy2pos = function(x, y) {
      return x + y * this.gameSize;
    };

    Reversi.prototype.pos2xy = function(pos) {
      return [pos % this.gameSize, Math.floor(pos / this.gameSize)];
    };

    Reversi.prototype._getSprite = function(pos) {
      var height, stone, width, x, y, _ref, _ref1, _ref2;

      _ref = [Reversi.STONE_IMAGE_WIDTH, Reversi.STONE_IMAGE_HEIGHT], width = _ref[0], height = _ref[1];
      stone = new Sprite(width, height);
      stone.image = new Surface(width * 5, height);
      stone.pos = pos;
      _ref1 = this.pos2xy(pos), x = _ref1[0], y = _ref1[1];
      stone.frame = 0;
      stone.scale(this.scale, this.scale);
      _ref2 = [x * width * this.scale, y * height * this.scale], stone.x = _ref2[0], stone.y = _ref2[1];
      stone.image.draw(enchant.Game.instance.assets[Reversi.VOID], 0, 0, width, height, 0, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.BLACK], 0, 0, width, height, width, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.WHITE], 0, 0, width, height, width * 2, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.HINT_B], 0, 0, width, height, width * 3, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.HINT_W], 0, 0, width, height, width * 4, 0, width, height);
      return stone;
    };

    Reversi.prototype.createBoard = function() {
      var pos, _i, _ref;

      this.SPRITES = [];
      for (pos = _i = 0, _ref = this.num_stone; 0 <= _ref ? _i < _ref : _i > _ref; pos = 0 <= _ref ? ++_i : --_i) {
        this.SPRITES.push(this._getSprite(pos));
      }
      this.firstScene();
      return this.SPRITES;
    };

    Reversi.prototype.firstScene = function() {
      var first, i, _i, _ref;

      for (i = _i = 0, _ref = this.num_stone; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.SPRITES[i].frame = 0;
        this.BoardState[i] = 0;
      }
      first = this.gameSize * (Math.floor(this.gameSize / 2 - 1)) + Math.floor(this.gameSize / 2 - 1);
      this.SPRITES[first].frame = this.SPRITES[first + this.gameSize + 1].frame = 2;
      this.BoardState[first] = this.BoardState[first + this.gameSize + 1] = -1;
      this.SPRITES[first + 1].frame = this.SPRITES[first + this.gameSize].frame = 1;
      this.BoardState[first + 1] = this.BoardState[first + this.gameSize] = 1;
      this.BlackStone = this.WhiteStone = 2;
      return document.myForm.black.value = document.myForm.white.value = 2;
    };

    Reversi.prototype.checkInvert = function() {
      var c, canPuts, ddx, ddy, dx, dy, i, pos, turnX, x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

      canPuts = [];
      turnX = (-1) * this.turn;
      for (pos = _i = 0, _ref = this.num_stone; 0 <= _ref ? _i < _ref : _i > _ref; pos = 0 <= _ref ? ++_i : --_i) {
        if (this.BoardState[pos] === 0) {
          _ref1 = this.pos2xy(pos), x = _ref1[0], y = _ref1[1];
          for (i = _j = 0, _ref2 = dXY.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            _ref3 = [dXY[i][0], dXY[i][1]], dx = _ref3[0], dy = _ref3[1];
            _ref4 = [1, dx, dy], c = _ref4[0], ddx = _ref4[1], ddy = _ref4[2];
            while (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
              _ref5 = [c + 1, ddx + dx, ddy + dy], c = _ref5[0], ddx = _ref5[1], ddy = _ref5[2];
            }
            if (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === this.turn) && (c > 1)) {
              this.BoardState[pos] = 2;
              this.SPRITES[pos].frame = (this.turn > 0 ? 3 : 4);
              canPuts.push(pos);
              break;
            }
          }
        }
      }
      return canPuts;
    };

    Reversi.prototype.showStone = function(stone, opts) {
      var next_frame, x, y, _ref, _ref1, _ref2;

      if (opts == null) {
        opts = {
          delay: 0,
          turn: this.turn
        };
      }
      _ref = [null, null], x = _ref[0], y = _ref[1];
      if (opts.pos) {
        _ref1 = this.pos2xy(opts.pos), x = _ref1[0], y = _ref1[1];
        _ref2 = [x + 1, y + 1], x = _ref2[0], y = _ref2[1];
      }
      next_frame = opts.turn === 1 ? 1 : 2;
      if ((this.players[0] > 0 && this.players[1] > 0) || (this.replay_mode === true)) {
        return stone.frame = next_frame;
      } else {
        if (stone.frame !== 0) {
          return stone.tl.delay(opts.delay * this.fps).scaleTo(0.1 * this.scale, this.scale, 0.2 * this.fps).then(function() {
            return this.frame = next_frame;
          }).scaleTo(this.scale, this.scale, this.fps * 0.2);
        } else {
          return stone.tl.delay(opts.delay * this.fps).then(function() {
            return this.frame = next_frame;
          });
        }
      }
    };

    Reversi.prototype.putStone = function(pos, opts) {
      var c, canPuts, cpuID, cpuPut, ddx, ddy, dx, dy, i, result, resultMessage, turnPos, turnX, x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

      if (opts == null) {
        opts = {
          delay: 0,
          turn: this.turn
        };
      }
      if (!this.start) {
        return setMessage("[スタート！]を押してください！");
      } else if ((this.replay_mode === false) && (this.BoardState[pos] !== 2)) {
        return setMessage("置けません！");
      } else {
        for (i = _i = 0, _ref = this.num_stone; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (this.BoardState[i] === 2) {
            this.BoardState[i] = 0;
            this.SPRITES[i].frame = 0;
          }
        }
        _ref1 = this.pos2xy(pos), x = _ref1[0], y = _ref1[1];
        setMessage("(" + (x + 1) + ", " + (y + 1) + ") に置きました！");
        this.recordPlay([this.turn, x + 1, y + 1]);
        turnX = (-1) * this.turn;
        for (i = _j = 0, _ref2 = dXY.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
          _ref3 = [dXY[i][0], dXY[i][1]], dx = _ref3[0], dy = _ref3[1];
          _ref4 = [1, dx, dy], c = _ref4[0], ddx = _ref4[1], ddy = _ref4[2];
          while (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
            _ref5 = [c + 1, ddx + dx, ddy + dy], c = _ref5[0], ddx = _ref5[1], ddy = _ref5[2];
          }
          if (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === this.turn)) {
            _ref6 = [c - 1, ddx - dx, ddy - dy], c = _ref6[0], ddx = _ref6[1], ddy = _ref6[2];
            while (c > 0) {
              this.BoardState[this.xy2pos(x + ddx, y + ddy)] = this.turn;
              if (this.turn > 0) {
                this.BlackStone++;
                this.WhiteStone--;
              } else {
                this.WhiteStone++;
                this.BlackStone--;
              }
              turnPos = this.xy2pos(x + ddx, y + ddy);
              this.showStone(this.SPRITES[turnPos], {
                delay: opts.delay + 0.3,
                turn: this.turn,
                pos: turnPos
              });
              _ref7 = [c - 1, ddx - dx, ddy - dy], c = _ref7[0], ddx = _ref7[1], ddy = _ref7[2];
            }
          }
        }
        this.BoardState[pos] = this.turn;
        if (!this.SPRITES[pos]) {
          alert(pos);
        }
        this.showStone(this.SPRITES[pos], {
          delay: opts.delay,
          turn: this.turn,
          pos: pos
        });
        if (this.turn > 0) {
          this.BlackStone++;
        } else {
          this.WhiteStone++;
        }
        document.myForm.black.value = this.BlackStone;
        document.myForm.white.value = this.WhiteStone;
        this.turn *= -1;
        canPuts = this.checkInvert();
        if (canPuts.length === 0) {
          setMessage(this.turn > 0 ? "先手はパスです！" : "後手はパスです！");
          this.recordPlay([this.turn, 0, 0]);
          this.turn *= -1;
          canPuts = this.checkInvert();
          if (canPuts.length === 0) {
            setStatMessage("はじめから");
            result = this.gameResult();
            resultMessage = result === 0 ? "引分け" : result > 0 ? "黒の勝ち" : "白の勝ち";
            setMessage("終了 (" + resultMessage + ")");
            return;
          }
        }
        if (((this.turn === 1 && this.players[0] > 0) || (this.turn === -1 && this.players[1] > 0)) && (this.replay_mode === false)) {
          cpuID = this.turn === 1 ? this.players[0] - 1 : this.players[1] - 1;
          cpuPut = this.cpus[cpuID].play(this.BoardState.slice(0), {
            turn: this.turn,
            canPuts: canPuts.slice(0)
          });
          if (cpuPut !== null) {
            this.putStone(cpuPut, {
              delay: opts.delay + 0.8,
              turn: this.turn
            });
          }
        }
        return null;
      }
    };

    Reversi.prototype.gameResult = function() {
      var r, s, _i, _len, _ref;

      r = 0;
      _ref = this.BoardState;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        r += s;
      }
      return r;
    };

    Reversi.prototype.recordPlay = function(pos) {
      if (!this.replay_mode) {
        if (this.play_pos !== this.records.length) {
          this.records = this.records.slice(0, this.play_pos);
        }
        this.records.push(pos);
        return this.play_pos = this.records.length;
      }
    };

    Reversi.prototype.exitReplay = function() {
      return this.replay_mode = false;
    };

    Reversi.prototype.replay = function(hands, len) {
      var i, pos, _i;

      this.replay_mode = true;
      this.firstScene();
      this.turn = 1;
      if (len < 0) {
        len = 0;
      }
      if (len > hands.length) {
        len = hands.length;
      }
      if (len > 0) {
        for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
          pos = (hands[i][1] - 1) + (hands[i][2] - 1) * this.gameSize;
          if (pos >= 0) {
            this.turn = hands[i][0];
            this.putStone(pos);
          }
        }
      }
      if (len <= 0) {
        setMessage("初期画面を表示しています。");
      }
      this.play_pos = len;
      return this.replay_mode = false;
    };

    Reversi.prototype.historyTop = function() {
      return this.replay(this.records, 0);
    };

    Reversi.prototype.historyLast = function() {
      return this.replay(this.records, this.records.length);
    };

    Reversi.prototype.history = function(step) {
      return this.replay(this.records, this.play_pos + step);
    };

    Reversi.prototype.savePlay = function() {
      return alert(JSON.stringify({
        black: this.BlackStone,
        white: this.WhiteStone,
        play: this.records
      }));
    };

    Reversi.prototype.loadPlay = function() {
      return console.log("未実装");
    };

    Reversi.prototype.setPlayers = function() {
      return this.players = [document.myForm.first.selectedIndex, document.myForm.second.selectedIndex];
    };

    Reversi.prototype.gameStart = function() {
      var canPuts;

      if (!this.start) {
        this.setPlayers();
        this.start = true;
        this.records = [];
        this.play_pos = 0;
        setMessage("ゲームスタート！！");
        setStatMessage("やりなおす");
        canPuts = this.checkInvert();
        if (this.players[0] > 0 && canPuts.length > 0) {
          return this.putStone(this.cpus[this.players[0] - 1].play(this.BoardState.slice(0), {
            turn: this.turn,
            canPuts: canPuts.slice(0)
          }));
        }
      } else {
        if (confirm("本当にやり直しますか？")) {
          this.firstScene();
          this.turn = 1;
          this.start = false;
          setStatMessage("スタート！");
          return setMessage("やりなおしました");
        }
      }
    };

    setMessage = function(msg) {
      return document.myForm.myMsg.value = msg;
    };

    setStatMessage = function(msg) {
      return document.myForm.start.value = msg;
    };

    return Reversi;

  })();

  enchant();

  window.onload = function() {
    var core, game_board_width, game_size, reversi;

    game_size = 8;
    game_board_width = 320;
    core = new Core(game_board_width + 10, game_board_width + 10);
    reversi = new Reversi(core, game_size, Math.floor(game_board_width / game_size));
    this.reversi = reversi;
    reversi.setCPUs([new AI_First(), new AI_Random(), new AI_Gain(), new AI_Montecarlo(), new AI_Negamax(2), new AI_Negamax(3), new AI_Negamax(4), new AI_Negamax(5)].slice(0));
    core.onload = function() {
      var board, stone, _i, _len, _results;

      board = reversi.createBoard();
      _results = [];
      for (_i = 0, _len = board.length; _i < _len; _i++) {
        stone = board[_i];
        core.rootScene.addChild(stone);
        _results.push(stone.addEventListener('touchend', function() {
          reversi.exitReplay();
          reversi.setPlayers();
          return reversi.putStone(this.pos);
        }));
      }
      return _results;
    };
    return core.start();
  };

  AI_Base = (function() {
    var dXY;

    function AI_Base() {}

    dXY = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];

    AI_Base.prototype.numStone = 64;

    AI_Base.prototype.gameSize = 8;

    AI_Base.prototype.play = function(boardState, opts) {
      if (opts == null) {
        opts = {};
      }
    };

    AI_Base.prototype.xy2pos = function(x, y) {
      return x + y * this.gameSize;
    };

    AI_Base.prototype.pos2xy = function(pos) {
      return [pos % this.gameSize, Math.floor(pos / this.gameSize)];
    };

    AI_Base.prototype.isInBoard = function(x, y) {
      return (x >= 0) && (x < this.gameSize) && (y >= 0) && (y < this.gameSize);
    };

    AI_Base.prototype.putStone = function(boardState, pos, turn, doTurn) {
      var c, ddx, ddy, dx, dy, gain, i, turnX, x, y, _i, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

      if (doTurn == null) {
        doTurn = false;
      }
      if (boardState[pos] !== 0) {
        return -1;
      }
      turnX = turn * (-1);
      gain = 0;
      _ref = this.pos2xy(pos), x = _ref[0], y = _ref[1];
      for (i = _i = 0, _ref1 = dXY.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _ref2 = [dXY[i][0], dXY[i][1]], dx = _ref2[0], dy = _ref2[1];
        _ref3 = [1, dx, dy], c = _ref3[0], ddx = _ref3[1], ddy = _ref3[2];
        while (this.isInBoard(x + ddx, y + ddy) && (boardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
          _ref4 = [c + 1, ddx + dx, ddy + dy], c = _ref4[0], ddx = _ref4[1], ddy = _ref4[2];
        }
        if (this.isInBoard(x + ddx, y + ddy) && boardState[this.xy2pos(x + ddx, y + ddy)] === turn) {
          _ref5 = [c - 1, ddx - dx, ddy - dy], c = _ref5[0], ddx = _ref5[1], ddy = _ref5[2];
          while (c > 0) {
            if (doTurn) {
              boardState[this.xy2pos(x + ddx, y + ddy)] = turn;
            }
            _ref6 = [c - 1, ddx - dx, ddy - dy], c = _ref6[0], ddx = _ref6[1], ddy = _ref6[2];
            gain++;
          }
        }
      }
      if (doTurn) {
        boardState[pos] = turn;
      }
      return gain;
    };

    AI_Base.prototype.checkInvert = function(board, turn) {
      var c, canPuts, ddx, ddy, dx, dy, i, pos, turnX, x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

      canPuts = [];
      turnX = (-1) * turn;
      for (pos = _i = 0, _ref = this.numStone; 0 <= _ref ? _i < _ref : _i > _ref; pos = 0 <= _ref ? ++_i : --_i) {
        if (board[pos] === 0) {
          _ref1 = this.pos2xy(pos), x = _ref1[0], y = _ref1[1];
          for (i = _j = 0, _ref2 = dXY.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            _ref3 = [dXY[i][0], dXY[i][1]], dx = _ref3[0], dy = _ref3[1];
            _ref4 = [1, dx, dy], c = _ref4[0], ddx = _ref4[1], ddy = _ref4[2];
            while (this.isInBoard(x + ddx, y + ddy) && (board[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
              _ref5 = [c + 1, ddx + dx, ddy + dy], c = _ref5[0], ddx = _ref5[1], ddy = _ref5[2];
            }
            if (this.isInBoard(x + ddx, y + ddy) && (board[this.xy2pos(x + ddx, y + ddy)] === turn) && (c > 1)) {
              canPuts.push(pos);
              break;
            }
          }
        }
      }
      return canPuts;
    };

    return AI_Base;

  })();

  AI_First = (function() {
    function AI_First() {}

    AI_First.prototype.play = function(boardState, opts) {
      if (opts == null) {
        opts = {};
      }
      if (opts.canPuts.length === 0) {
        return null;
      } else {
        return opts.canPuts[0];
      }
    };

    return AI_First;

  })();

  AI_Random = (function() {
    function AI_Random() {}

    AI_Random.prototype.play = function(boardState, opts) {
      if (opts == null) {
        opts = {};
      }
      if (opts.canPuts.length === 0) {
        return null;
      } else {
        return opts.canPuts[Math.floor(Math.random() * opts.canPuts.length)];
      }
    };

    return AI_Random;

  })();

  AI_Gain = (function(_super) {
    __extends(AI_Gain, _super);

    function AI_Gain() {}

    AI_Gain.prototype.play = function(boardState, opts) {
      var ans, gainMax, gains, i, pos, score, turn, _i, _j, _len, _ref, _ref1;

      if (opts == null) {
        opts = {};
      }
      turn = opts.turn;
      ans = null;
      gains = {};
      gainMax = -1;
      for (i = _i = 0, _ref = this.numStone; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (boardState[i] === 2) {
          boardState[i] = 0;
        }
      }
      _ref1 = opts.canPuts;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        pos = _ref1[_j];
        score = this.putStone(boardState, pos, turn, false);
        if (gainMax < score) {
          gainMax = score;
        }
        if (gains[score]) {
          gains[score].push(pos);
        } else {
          gains[score] = [pos];
        }
      }
      console.log("#--- AI_gains ");
      console.log(gains);
      pos = gainMax <= 0 ? nyll : gains[gainMax][Math.floor(Math.random() * gains[gainMax].length)];
      console.log("#--- AI_Gain turn:" + turn + ", pos:" + pos);
      return pos;
    };

    return AI_Gain;

  })(AI_Base);

  AI_Montecarlo = (function(_super) {
    var dXY;

    __extends(AI_Montecarlo, _super);

    function AI_Montecarlo() {
      _ref = AI_Montecarlo.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    dXY = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];

    AI_Montecarlo.prototype.numStone = 64;

    AI_Montecarlo.prototype.gameSize = 8;

    AI_Montecarlo.prototype.playCount = 5;

    AI_Montecarlo.prototype.play = function(boardState, opts) {
      var ans, drowCount, i, p, pos, turn, winCount, winMax, winer, wins, workBoard, _i, _j, _k, _len, _ref1, _ref2, _ref3;

      if (opts == null) {
        opts = {};
      }
      turn = opts.turn;
      ans = null;
      wins = {};
      winMax = -1;
      for (i = _i = 0, _ref1 = this.numStone; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        if (boardState[i] === 2) {
          boardState[i] = 0;
        }
      }
      winMax = -1;
      wins = {};
      _ref2 = opts.canPuts;
      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
        pos = _ref2[_j];
        winCount = 0;
        drowCount = 0;
        for (p = _k = 0, _ref3 = this.playCount; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; p = 0 <= _ref3 ? ++_k : --_k) {
          workBoard = boardState.slice(0);
          winer = this.playGame(workBoard, turn, pos);
          if (winer === turn) {
            winCount++;
          }
          if (winer === 0) {
            drowCount++;
          }
        }
        if (winCount === 0 && drowCount === 0) {
          winCount = -1;
        }
        if (wins[winCount]) {
          wins[winCount].push(pos);
        } else {
          wins[winCount] = [pos];
        }
        if (winMax < winCount) {
          winMax = winCount;
        }
      }
      console.log("#--- AI_Montecarlo(playCount=" + this.playCount + " turn:" + turn + ", pos:" + wins[winMax][0]);
      return wins[winMax][0];
    };

    AI_Montecarlo.prototype.playGame = function(board, turn, pos) {
      var canPuts, i, pass, win, _i, _len;

      pass = 0;
      while (pass < 2) {
        if (pos >= 0) {
          this.putStone(board, pos, turn, true);
        }
        turn *= -1.;
        canPuts = this.checkInvert(board, turn);
        if (canPuts.length === 0) {
          pos = null;
          pass++;
        } else {
          pos = canPuts[Math.floor(Math.random() * canPuts.length)];
          pass = 0;
        }
      }
      win = 0;
      for (_i = 0, _len = board.length; _i < _len; _i++) {
        i = board[_i];
        win += i;
      }
      if (win === 0) {
        return 0;
      }
      if (win > 0) {
        return 1;
      } else {
        return -1;
      }
    };

    return AI_Montecarlo;

  })(AI_Base);

  Rating = (function() {
    function Rating() {}

    Rating.rate9 = [127, -32, 0, -1, -1, -1, 0, -32, 127, -32, -64, -1, -1, -1, -1, -1, -64, -32, 0, -1, 0, -1, -1, -1, 0, -1, 0, -1, -1, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, -1, -1, 0, -1, 0, -1, -1, -1, 0, -1, 0, -32, -64, -1, -1, -1, -1, -1, -64, -32, 127, -32, 0, -1, -1, -1, 0, -32, 127];

    Rating.rate8 = [127, -32, 0, -1, -1, 0, -32, 127, -32, -64, -1, -1, -1, -1, -64, -32, 0, -1, 0, -1, -1, 0, -1, 0, -1, -1, -1, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, -1, -1, -1, 0, -1, 0, -1, -1, 0, -1, 0, -32, -64, -1, -1, -1, -1, -64, -32, 127, -32, 0, -1, -1, 0, -32, 127];

    Rating.rate7 = [127, -32, 0, -1, 0, -32, 127, -32, -64, -1, -1, -1, -64, -32, 0, -1, 0, -1, 0, -1, 0, -1, -1, -1, 0, -1, -1, -1, 0, -1, 0, -1, 0, -1, 0, -32, -64, -1, -1, -1, -64, -32, 127, -32, 0, -1, 0, -32, 127];

    Rating.rate6 = [127, -32, 0, 0, -32, 127, -32, -64, -1, -1, -64, -32, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, -32, -64, -1, -1, -64, -32, 127, -32, 0, 0, -32, 127];

    Rating.rate5 = [127, -32, 0, -32, 127, -32, -64, -1, -64, -32, 0, -1, 0, -1, 0, -32, -64, -1, -64, -32, 127, -32, 0, -32, 127];

    Rating.rate4 = [127, -32, -32, 127, -32, -64, -64, -32, -32, -64, -64, -32, 127, -32, -32, 127];

    Rating.evalBoard = function(board, gameSize, mode) {
      var pos, rate, score, _i, _j, _ref1, _ref2;

      rate = Rating["rate" + gameSize];
      score = 0;
      if (mode === "gain") {
        for (pos = _i = 0, _ref1 = rate.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; pos = 0 <= _ref1 ? ++_i : --_i) {
          score += board[pos];
        }
      } else {
        for (pos = _j = 0, _ref2 = rate.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; pos = 0 <= _ref2 ? ++_j : --_j) {
          score += board[pos] * rate[pos];
        }
      }
      return score;
    };

    return Rating;

  })();

  AI_Negamax = (function(_super) {
    __extends(AI_Negamax, _super);

    function AI_Negamax(depth, gameSize) {
      this.depth = depth != null ? depth : 5;
      this.gameSize = gameSize != null ? gameSize : 8;
    }

    AI_Negamax.prototype.play = function(boardState, opts) {
      var depth, i, mode, num_rest, pos, posAry, turn, v, _i, _ref1, _ref2;

      if (opts == null) {
        opts = {};
      }
      turn = opts.turn;
      num_rest = 0;
      for (i = _i = 0, _ref1 = this.numStone; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        if (boardState[i] === 2) {
          boardState[i] = 0;
        }
        if (boardState[i] === 0) {
          num_rest++;
        }
      }
      depth = this.depth;
      mode = "";
      if (num_rest <= 10) {
        mode = "gain";
        depth = num_rest;
      }
      _ref2 = this.negaMax(depth, boardState, turn, mode), v = _ref2[0], posAry = _ref2[1];
      pos = posAry[Math.floor(Math.random() * posAry.length)];
      console.log("#--- AI_Negamax(depth=" + this.depth + " turn:" + turn + ", pos:" + pos + ", v=" + v);
      return pos;
    };

    AI_Negamax.prototype.negaMax = function(depth, board, turn, mode) {
      var bestPos, bestV, canPuts, evaled, nextBoard, nextPos, v, workBoard, _i, _len;

      if (depth === 0) {
        return [Rating.evalBoard(board, this.gameSize, mode) * turn, null];
      }
      bestV = -32000;
      bestPos = {};
      workBoard = board.slice(0);
      canPuts = this.checkInvert(workBoard, turn);
      for (_i = 0, _len = canPuts.length; _i < _len; _i++) {
        nextPos = canPuts[_i];
        nextBoard = workBoard.slice(0);
        this.putStone(nextBoard, nextPos, turn, true);
        evaled = this.negaMax(depth - 1, nextBoard, (-1) * turn, mode);
        v = (-1) * evaled[0];
        if (bestPos[v]) {
          bestPos[v].push(nextPos);
        } else {
          bestPos[v] = [nextPos];
        }
        if (bestV <= v) {
          bestV = v;
        }
      }
      return [bestV, bestPos[bestV]];
    };

    return AI_Negamax;

  })(AI_Base);

}).call(this);
